<!doctype html>

<html lang="en">
<head>
  <meta charset="utf-8">

  <title>Ham by Spam</title>
  <meta name="description" content="">
  <meta name="author" content="">

  <link rel="stylesheet" href="">

  {#
    Reset CSS on vain poistamassa padding, margin, ja muut legacy asiat.
    Jos käytetään jotain websivun frameworkkia, voidaan se poistaa ongelmitta.
  #}
  <link rel="stylesheet" href="{{url_for('static', filename='reset.css')}}">

    <style>
    #graph svg {
        display: block;
    }

    .links line {
        stroke: rgba(0, 0, 0, 0.692);
        stroke-opacity: 0.6;
    }

    .nodes circle {
        stroke: #fff;
        stroke-width: 1.5px;
    }

    .nodes .node-info {
        display: none;
    }
    .nodes .active .node-info {
       display: block;
    }

    </style>

</head>

<body>

  <div id="graph"></div>


<script src="https://d3js.org/d3.v4.js"></script>
<script>

var nodes = [],
    links = [],
    parties = [];

var width = parseInt(window.innerWidth),
    height = parseInt(window.innerHeight);

d3.json('{{url_for(".data_parties")}}', function(data) {
    parties = data;
    run();
});
d3.json('{{url_for(".data_nodes")}}', function(data) {
    nodes = data;
    run();
});
d3.json('{{url_for(".data_links")}}', function(data) {
    var links_map = {};
    
    var attrs = {};

    // Collect node links, from closest to furthest.
    data.sort((a, b) => a["distance"] - b["distance"] ).forEach((element) => {

        // Pointers to node indexes.
        source = element["source"];
        target = element["target"];
        let k = [parseInt(source), parseInt(target)].sort();

        if(!(source in links_map)) links_map[source] = [];
        if(!(target in links_map)) links_map[target] = [];
        if(!(k in attrs)) attrs[k] = {
            distance: element.distance + 0.1
        };

        // Pointers
        let src_links = links_map[source];
        let trg_links = links_map[target];

        if( src_links.length < 3) src_links.push(target);
        if( trg_links.length < 3) trg_links.push(source);
    });

    for(let source in links_map) {
        for(let target of links_map[source]) {
            let [src, trg] = [parseInt(source), parseInt(target)].sort();
            links.push(Object.assign({
                source: src,
                target: trg
            }, attrs[[src,trg]]));
        }
    }

    run();
});

function node_color(d) {
    let party = parties.find(function(x) {
        if(x.itemLabel.includes(d.party)) return true; 
        if("itemAltLabel" in x) return x.itemAltLabel.includes(d.party)
    });
    let color = party && "sRGB_color_hex_triplet" in party ? "#"+party.sRGB_color_hex_triplet : "#CCC"

    return color;
}

function run() {
    {# HÄX - älä suorita ellei dataa ole ladattu. #}
    if(nodes.length == 0 || links.length == 0 || parties.length == 0) return;


    // Link into nodes.
    var svg = d3.select("#graph")
        .append("svg")
            .attr("width", width)
            .attr("height", height);
            
    var zoom = d3.zoom()
        .on("zoom", function () {
            graph_layer.attr("transform", d3.event.transform)
        });

    var graph_layer = svg.call(zoom).append("g").attr("id", "graph_layer");

    var simulation = d3.forceSimulation()
        .force("link", d3.forceLink()
            .id(function(d) { return d.index; })
            .distance(function(d) {return d.distance * 30;}))
        .force("charge", d3.forceManyBody())
        .force("center", d3.forceCenter(width / 2, height / 2));

    var link = graph_layer.append("g")
        .attr("class", "links")
        .selectAll("line")
        .data(links)
        .enter()
        .append("line")
        .attr("stroke-width", 1);

    var node = graph_layer.append("g")
        .attr("class", "nodes")
        .selectAll("g")
        .data(nodes)
        .enter().append("g")
        
    var circles = node.append("circle")
        .attr("r", 5)
        .attr("fill", node_color)
        // .call(d3.drag()
        //     .on("start", dragstarted)
        //     .on("drag", dragged)
        //     .on("end", dragended));
        .on("click", function(obj) {
            var g = d3.select(this.parentElement);
            var toggle = !g.classed("active");
            g.classed("active", toggle);

        });

    var lables = node.append("text")
        .text(function(d) {
            return d.party;
        })
        .classed("node-info", true)
        .attr('x', 6)
        .attr('y', 3);

    node.append("title")
        .text(function(d) { return d.name+"\n"+d.party; });

    simulation
        .nodes(nodes)
        .on("tick", ticked);

    simulation.force("link")
        .links(links);

    function ticked() {
        link
            .attr("x1", function(d) { return d.source.x; })
            .attr("y1", function(d) { return d.source.y; })
            .attr("x2", function(d) { return d.target.x; })
            .attr("y2", function(d) { return d.target.y; });

        node.attr("transform", function(d) {
            return "translate(" + d.x + "," + d.y + ")";
        })
    }

    function dragstarted(d) {
        if (!d3.event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
    }

    function dragged(d) {
        d.fx = d3.event.x;
        d.fy = d3.event.y;
    }

    function dragended(d) {
        if (!d3.event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
    }

    d3.select(window).on("resize", function() {
        width = parseInt(window.innerWidth);
        height = parseInt(window.innerHeight);

        console.log("resize");

        svg.attr("width", width)
           .attr("height", height);

    });

}


</script>

</body>
</html>
